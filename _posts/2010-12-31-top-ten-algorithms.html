---
layout: post
title:  'Top ten algorithms preprints of 2010'
date:   2010-12-31 13:10:00
tags:   [algorithms, papers]
---
<p>There were <a href="http://arxiv.org/list/cs.DS/10">643 preprints</a> posted to the data structures and algorithms (cs.DS) section of arXiv.org in 2010, up from 499 in 2009 and 334 in 2008. Here is a very idiosyncratic top-ten of this year&#x27;s crop (in chronological order, <a href="http://arxiv.org/a/eppstein_d_1">my own papers</a> excluded).</p>

<ul>
<li><p><b>An O(loglog n)-Competitive Binary Search Tree with Optimal Worst-Case Access Times</b>, Prosenjit Bose, Karim Douïeb, Vida Dujmović, and Rolf Fagerberg, <a href="http://arxiv.org/abs/1003.0139">arXiv:1003.0139</a>. When given random update sequences, binary search trees must take logarithmic time per update. But in most applications, the update sequences are not random.
A very important open problem in data structures, the <a href="http://en.wikipedia.org/wiki/Splay_tree#Dynamic_optimality_conjecture">dynamic optimality conjecture</a>, asks whether there is an adaptive binary search tree data structure that takes advantage of all possible non-randomness in the input, by achieving a constant <a href="http://en.wikipedia.org/wiki/Competitive_analysis_(online_algorithm)">competitive ratio</a> when its time performance is compared against that of a rotation-based binary tree that performs the optimal sequence of rotations for a given input sequence. More specifically the conjecture is that <a href="http://en.wikipedia.org/wiki/Splay_tree">splay trees</a> are that optimal structure. While it is not known how to achieve constant competitive ratios, it is known how to get within a doubly-logarithmic factor of the optimal rotation sequence, but the known solutions paid the double-log penalty even in the worst case time per update. The new &quot;zipper tree&quot; data structure keeps the double-log competitive ratio of the best online algorithms, but combines it with the logarithmic worst-case update times of non-adaptive binary search tree data structures, getting the best of both worlds.</p></li>

<li><p><b>Are there any good digraph width measures?</b>, Robert Ganian, Petr Hliněný, Joachim Kneis, Daniel Meister, Jan Obdržálek, Peter Rossmanith, and Somnath Sikdar, <a href="http://arxiv.org/abs/1004.1485">arXiv:1004.1485</a>. Here &quot;good&quot; means something that acts like <a href="http://en.wikipedia.org/wiki/Tree_decomposition">treewidth</a> does for undirected graphs, in that bounded width leads to efficient algorithms for a big well-defined class of optimization problems. We would also like our width measures to be closed under something resembling <a href="http://en.wikipedia.org/wiki/Minor_(graph_theory)">graph minors</a> (the lack of this closure makes other measures such as <a href="http://en.wikipedia.org/wiki/Clique-width">clique-width</a> more difficult to use). And in addition, we would like an answer that is not just the trivial one of throwing away the edge orientations and using treewidth. The answer to the question seems to be &quot;no&quot;.</p></li>

<li><p><b>Optimal Stochastic Planarization</b>, Anastasios Sidiropoulos, <a href="http://arxiv.org/abs/1004.1666">arXiv:1004.1666</a>. If G is a graph of bounded genus g, then it&#x27;s possible to randomly choose how to cut and unfold the surface on which G is embedded into a planar surface, in polynomial time, in such a way that the distortion of the distances of G caused by the cutting and unfolding operations is only logarithmic in g. The result can be used to extend approximation algorithms from planar graphs to bounded-genus graphs with only a logarithmic dependence on g in the approximation ratio.</p></li>

<li><p><b>MapReduce Parallel Cuckoo Hashing and Oblivious RAM Simulations</b>, Michael T. Goodrich and Michael Mitzenmacher, <a href="http://arxiv.org/abs/1007.1259">arXiv:1007.1259</a>. Uses the <a href="http://en.wikipedia.org/wiki/Cuckoo_hashing">cuckoo hashing</a> data structure to provide optimal simulations of the <a href="http://en.wikipedia.org/wiki/Parallel_Random_Access_Machine">PRAM model</a> in the <a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce</a> framework, allowing a lot of past research on parallel algorithms to be ported to cloud computing.</p></li>

<li><p><b>Known Algorithms on Graphs of Bounded Treewidth are Probably Optimal</b>, Daniel Lokshtanov, Dániel Marx, Saket Saurabh, <a href="http://arxiv.org/abs/1007.5450">arXiv:1007.5450</a>. This paper shows tight connections between the <a href="http://en.wikipedia.org/wiki/Exponential_time_hypothesis">strong exponential time hypothesis</a> in exact exponential-time algorithms to <a href="http://en.wikipedia.org/wiki/Parameterized_complexity">fixed-parameter-tractable algorithms</a> on graphs of bounded <a href="http://en.wikipedia.org/wiki/Treewidth">treewidth</a>, implying that improvements to the treewidth-based algorithms are unlikely without reparameterization or simultaneous improvements to more basic problems like SAT.</p></li>

<li><p><b>Determinant Sums for Undirected Hamiltonicity</b>, Andreas Björklund, <a href="http://arxiv.org/abs/1008.0541">arXiv:1008.0541</a>. Many problems of searching through the permutations of a set of items (such as the Hamiltonian cycle problem of permuting the vertices of a graph so that each pair that is adjacent in the cyclic permutation is also adjacent in the input graph) can be solved by a dynamic programming algorithm that is sufficiently well known to be the subject of <a href="http://xkcd.com/399/">an xkcd cartoon</a>. But since Bellman, Held, and Karp found this in the early 1960s, no better time was known, even for the Hamiltonian cycle problem although the exponential space of the dynamic programming algorithm had been reduced to polynomial by several authors using <a href="http://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle">inclusion-exclusion</a> on numbers of walks. By counting numbers of weighted cycle covers mod 2 instead, and applying algebraic methods involving the <a href="http://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">Schwartz–Zippel lemma</a> to solve this cycle cover counting problem, Björklund significantly reduces the time complexity of the Hamiltonian cycle problem, to O(1.657<sup>n</sup>).</p></li>

<li><p><b>Finding Topological Subgraphs is Fixed-Parameter Tractable</b>, Martin Grohe, Ken-ichi Kawarabayashi, Dániel Marx, and Paul Wollan, <a href="http://arxiv.org/abs/1011.1827">arXiv:1011.1827</a>. Kuratowski&#x27;s theorem states that a graph is planar if and only if it does not have a subgraph isomorphic to a subdivision of K<sub>5</sub> or K<sub>3,3</sub>. So how does one solve this &quot;subgraph isomorphic to a subdivision of H&quot; problem? For the specific cases of K<sub>5</sub> or K<sub>3,3</sub> it was known, but this paper solves the more general problem of finding a topological H-minor, in polynomial time for any fixed H. The result is closely analogous to but not the same as the problem of finding a minor (subgraph isomorphic to a vertex-expansion of H).</p></li>

<li><p><b>The Power of Simple Tabulation Hashing</b>, Mihai Pătraşcu and Mikkel Thorup, <a href="http://arxiv.org/abs/1011.5200">arXiv:1011.5200</a>. A very simple multiplication-free hash function, looking up and xoring together random numbers from a table indexed by the bytes of the hash keys, performs well for many hashing algorithms despite its low degree of independence. (<a href="http://11011110.livejournal.com/209336.html">Previously</a>.)</p></li>

<li><p><b>Computing the Diameter Polynomially Faster than APSP</b>, Raphael Yuster, <a href="http://arxiv.org/abs/1011.6181">arXiv:1011.6181</a>. Fast matrix multiplication techniques can be used to find the farthest pair of points in an unweighted digraph, more quickly than known fast matrix multiplication techniques for finding all pairwise distances. Possibly this means that diameter is easier than all pairs shortest paths, or possibly it means that the all pairs problem can also be sped up in the same way; either one would be interesting. (<a href="http://11011110.livejournal.com/209641.html">Previously</a>.)</p></li>

<li><p><b>The Least Spanning Area of a Knot and the Optimal Bounding Chain Problem</b>, Nathan M. Dunfield and Anil N. Hirani, <a href="http://arxiv.org/abs/1012.3030">arXiv:1012.3030</a>. Every simple closed curve in 3d is the boundary of a two-dimensional <a href="http://en.wikipedia.org/wiki/Seifert_surface">Seifert surface</a>; the curve is unknotted if and only if this surface can be chosen to be topologically a disk, and it&#x27;s an important open question whether unknottedness (ore more generally the minimum genus of a Seifert surface) can be determined in polynomial time. In this paper it&#x27;s shown that a different optimal-Seifert-surface problem does have a polynomial solution: given a piecewise-linear closed curve in 3d, it&#x27;s possible to find in polynomial time the Seifert surface of minimum area. The authors are hopeful that similar techniques will also lead to a polynomial time solution of the minimum genus problem.</p></li>
</ul>
<br /><br /><hr /><br />
<h3>Comments:</h3>
<div style="margin-left: 0em; padding-top: 1em;">
<b>None</b>: <br />
<b>2010-12-31T22:18:32Z</b><br />
Thank you David, for providing a complementary alternative view of what is interesting in recent TCS developments.
Refreshening!

</div>
<div style="margin-left: 0em; padding-top: 1em;">
<b>udpn</b>: <br />
<b>2011-01-01T18:22:39Z</b><br />
The best overview of last year&#x27;s news in my feed ;)
</div>
<div style="margin-left: 3em; padding-top: 1em;">
<b>11011110</b>: <br />
<b>2011-01-01T19:59:28Z</b><br />
Thanks!
</div>
<div style="margin-left: 0em; padding-top: 1em;">
<b>pingback_bot</b>: Алгоритмы.<br />
<b>2011-01-02T10:57:43Z</b><br />
User livejournal user thesz referenced to your post from <a href="http://thesz.livejournal.com/1171794.html">Алгоритмы.</a> saying: [...] Интересная подборка по новым алгоритмам [...]
</div>
<div style="margin-left: 0em; padding-top: 1em;">
<b>None</b>: <br />
<b>2011-01-02T11:32:03Z</b><br />
I don&#x27;t understand any of this.
</div>
<div style="margin-left: 3em; padding-top: 1em;">
<b>11011110</b>: <br />
<b>2011-01-02T16:44:14Z</b><br />
Then you&#x27;re not part of the target audience for this post.
</div>
<div style="margin-left: 6em; padding-top: 1em;">
<b>ext_318517</b>: <br />
<b>2011-01-11T17:33:51Z</b><br />
I think you should make this a yearly tradition :). and the growth rate is stunning. Is there an easy way to trawl these numbers to plot a graph ? I&#x27;m now curious evidence can be documented across the different cs.XX fields for the increased use fo the arxiv
</div>
<div style="margin-left: 9em; padding-top: 1em;">
<b>11011110</b>: <br />
<b>2011-01-11T17:59:00Z</b><br />
I don&#x27;t know a page that gives all the numbers in one place, but it&#x27;s easy to get the number for each field in each year from arxiv.org/list/FIELD/YY: somewhere near the top of the page it says &quot;total of XX entries&quot;.

</div>
<div style="margin-left: 12em; padding-top: 1em;">
<b>ext_318517</b>: <br />
<b>2011-01-11T20:26:16Z</b><br />
yup. that works great. A little BeautifulSoup magic and I should have the numbers. 
</div>
<div style="margin-left: 15em; padding-top: 1em;">
<b>11011110</b>: <br />
<b>2011-01-11T20:51:18Z</b><br />
Just be careful not to hit them too fast, so you don&#x27;t trigger their rampaging robot countermeasures.
</div>
<div style="margin-left: 0em; padding-top: 1em;">
<b>None</b>: <br />
<b></b><br />

</div>

