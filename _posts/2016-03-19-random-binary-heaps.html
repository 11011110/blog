---
layout: post
title:  'Random binary heaps, separable permutations, and numbers that multiply to factorials'
date:   2016-03-19 18:45:00
tags:   [combinatorics]
---
<p>I recently asked my data structures class the following question: suppose you fill in an <i>n</i>-cell array by a random permutation. What is the probability that the result is a valid binary min-heap?</p>

<p>One way to solve this would be to count heaps, then divide by <i>n!</i>. For instance, for <i>n</i> = 5, there are eight heaps: there are four choices for the right child of the root, and two choices for how to order the two grandchildren, so the probability is 8/120 = 1/15.</p>

<p style="text-align:center"><img src="http://www.ics.uci.edu/~eppstein/0xDE/factorial-heaps/Heaps5.png" /></p>

<p>Alternatively, you can compute the probability a different way. Each node in the tree must have the minimum value among all its descendants. For a random permutation, the probability that it does is one over the number of descendants (counting the node as a descendant of itself). And the events that two nodes are minimum among their descendants turn out to be independent, so we can just multiply these probabilities together. A five-element heap has nodes whose numbers of descendants are 5, 3, 1, 1, 1, so the probability of getting a heap is one over the product of these numbers, 1/15. This calculation explains why the probability is a unit fraction, something that seems a bit mysterious when you calculate it the other way.</p>

<p>But now we have a nice sequence of integers, the inverses of these probabilities for different choices of <i>n</i>: <a href="http://oeis.org/A132862">1, 2, 3, 8, 15, 36, 63, etc</a>. And when we have a nice sequence of integers, we&#x27;d like them to count things. What do these numbers count? One possible answer is that they count a different set of labelings on the same complete binary trees: labelings for which, at each node, all left descendants are smaller than all right descendants. There are 15 such labelings, determined by the choice of any label at the root and any of the three remaining smallest values at its left child:</p>

<p style="text-align:center"><img src="http://www.ics.uci.edu/~eppstein/0xDE/factorial-heaps/AlmostSorted5.png" /></p>

<p>More generally, for any <i>n</i>-node tree <i>T</i>, say that a labeling of the nodes of <i>T</i> by the numbers from 1 to <i>n</i> is <i>T</i>-heap-ordered if, for any ancestor-descendant pair (<i>x</i>,<i>y</i>), we have that <i>x</i> &lt; <i>y</i>. And say that a labeling is <i>T</i>-almost-sorted if, for any pair (<i>x</i>,<i>y</i>) that are not in an ancestor-descendant relation, with <i>x</i> to the left of <i>y</i>, we have that <i>x</i> &lt; <i>y</i>. Then the product of the number of <i>T</i>-heap-ordered labelings and the number of <i>T</i>-almost-sorted labelings always equals <i>n</i>!.</p>

<p>We can take this one step farther, from trees to permutations. For any permutation <i>π</i> of the numbers from 1 to <i>n</i>, consider the two-dimensional set of points of the form (<i>i</i>,<i>π</i>(<i>i</i>)), and consider the labelings of these points by the numbers from 1 to <i>n</i>. Define a labeling to be <i>π</i>-upward if, for every two points oriented from southwest to northeast, the southwest point has a smaller label than the northeast point. And define a labeling to be <i>π</i>-downward if, for every two points oriented from northwest to southeast, the northwest point has a smaller label than the northeast point. Do the numbers of <i>π</i>-upward and <i>π</i>-downward labelings have a nice product formula? Not always. For instance, the permutaton 2413 has five <i>π</i>-upward labelings (below) and symmetrically five <i>π</i>-downward labelings. The product of these counts, 25, differs from <i>n</i>! = 24.</p>

<p style="text-align:center"><img src="http://www.ics.uci.edu/~eppstein/0xDE/factorial-heaps/2413-upward.png" /></p>

<p>However in some sense this is the only possible counterexample. For, when <i>π</i> is a <a href="https://en.wikipedia.org/wiki/Separable_permutation">separable permutation</a> (a permutation that avoids both 2413 and its mirror image 3142 as patterns) then the numbers of <i>π</i>-upward and <i>π</i>-downward labelings always multiply to <i>n</i>!.</p>

<p style="margin-left:2em"><i>Proof sketch:</i> in this case the dot pattern for <i>π</i> can be broken into the dot patterns for two smaller separable permutations, either southwest-northeast of each other (the direct sum of the two smaller permutations) or northwest-southeast (the skew sum). Suppose the sizes of the smaller permutations are <i>k</i> and <i>n</i> − <i>k</i>, and suppose they&#x27;re combined in a direct sum. Then by induction the product of the numbers of labelings in the two smaller dot patterns is <i>k</i>! and (<i>n</i> − <i>k</i>)!. Two <i>π</i>-upward labelings on the two smaller dot patterns can only be combined in one way to make a <i>π</i>-upward labeling on the whole pattern: every label in the southwest pattern has to be less than every label in the northeast pattern. However, two <i>π</i>-downward labelings on the two smaller dot patterns can be combined in many ways to make a <i>π</i>-downward labeling on the whole dot pattern: we can partition the <i>n</i> labels among the two patterns arbitrarily, and there are Choose(<i>n</i>,<i>k</i>) partitions to choose among. So the number of pairs of an upward and downward label on the whole pattern is the product of the numbers of pairs labelings on the two smaller patterns with the number of ways we can make this combination:
<i>k</i>! × (<i>n</i> − <i>k</i>)! × Choose(<i>n</i>,<i>k</i>) = <i>n</i>!. The case of a skew sum follows by a symmetric argument.</p>

<p>More strongly, this argument shows that any labeling of <i>π</i> can be generated uniquely from the trivial labeling (the one that labels each point by its <i>x</i>-coordinate) by a sequence of riffle shuffles, working bottom up in the recursive structure of <i>π</i> as a skew sum or direct sum of smaller permutations. At each skew sum or direct sum in this decomposition, combining smaller permutations of sizes <i>a</i> and <i>b</i>, we choose one of the Choose(<i>a</i> + <i>b</i>,<i>a</i>) possible riffles and apply it to the labels on the dot patterns of these two smaller permutations. If we do all of the riffles, we get an arbitrary labeling. But if we do only the riffles at  skew sums, we get a <i>π</i>-upward labeling, and if we do only the riffles at direct sums, we get a <i>π</i>-downward labeling. So this shows that an arbitrary labeling of <i>π</i> can be decomposed into a unique pair of an upward and downward labeling.</p>

<p>For every tree <i>T</i>, there is a drawing of <i>T</i> as the dot pattern of a separable permutation <i>π</i> such that the <i>π</i>-upward labelings are the same as the <i>T</i>-heap-ordered labelings and the <i>π</i>-downward labelings are the same as the <i>T</i>-almost-sorted labelings. One can construct <i>π</i> as the direct sum of the root of <i>T</i> (represented by a one-element permutation) with the skew sum of the subtrees of <i>T</i> (represented recursively). For instance, the complete binary tree used for 5-element binary heaps is represented in this way by the permutation 13542:</p>

<p style="text-align:center"><img src="http://www.ics.uci.edu/~eppstein/0xDE/factorial-heaps/Tree2Perm.png" /></p>

<p>So, the product formula for labelings of trees is a special case of the product formula for separable permutations.</p>
<br /><br /><hr /><br />
<h3>Comments:</h3>
<div style="margin-left: 0em; padding-top: 1em;">
<b>None</b>: <br />
<b></b><br />

</div>

